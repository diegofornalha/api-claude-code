#!/usr/bin/env python3
"""
Claude - Interface de chat interativo para o Claude Code SDK.
Digite suas mensagens e pressione Enter para enviar.
"""

import sys
import asyncio
import os
import json
import requests
from pathlib import Path
from datetime import datetime

# Adiciona o diretÃ³rio ao path
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, parent_dir)

from src import AssistantMessage, TextBlock, ResultMessage, ClaudeSDKClient, __version__

# ConfiguraÃ§Ãµes do viewer
VIEWER_API_URL = "http://localhost:3043"

async def get_sessions():
    """Busca sessÃµes diretamente do sistema de arquivos."""
    try:
        # Primeiro tenta usar a API HTTP se disponÃ­vel
        try:
            response = requests.get(f"{VIEWER_API_URL}/api/sessions", timeout=2)
            if response.status_code == 200:
                return response.json()
        except:
            pass
        
        # Se falhar, lÃª diretamente do sistema de arquivos
        sessions = []
        claude_projects_path = Path.home() / ".claude" / "projects"
        
        if not claude_projects_path.exists():
            print(f"âŒ DiretÃ³rio de projetos nÃ£o encontrado: {claude_projects_path}")
            return []
        
        # Percorre todos os diretÃ³rios de projeto
        for project_dir in claude_projects_path.iterdir():
            if project_dir.is_dir():
                # Busca arquivos .jsonl (sessÃµes)
                for session_file in project_dir.glob("*.jsonl"):
                    try:
                        # ObtÃ©m informaÃ§Ãµes bÃ¡sicas da sessÃ£o
                        session_id = session_file.stem
                        # MantÃ©m o nome original do diretÃ³rio para correspondÃªncia
                        directory = project_dir.name
                        
                        # ObtÃ©m Ãºltima modificaÃ§Ã£o
                        last_modified = datetime.fromtimestamp(session_file.stat().st_mtime)
                        last_interaction = last_modified.strftime("%Y-%m-%d %H:%M:%S")
                        
                        sessions.append({
                            "session_id": session_id,
                            "directory": directory,
                            "last_interaction": last_interaction,
                            "file_path": str(session_file)
                        })
                    except Exception as e:
                        continue
        
        # Ordena por data de Ãºltima interaÃ§Ã£o (mais recentes primeiro)
        sessions.sort(key=lambda x: x.get('last_interaction', ''), reverse=True)
        return sessions
        
    except Exception as e:
        print(f"âŒ Erro ao carregar sessÃµes: {str(e)}")
        return []

async def session_browser():
    """Interface de navegaÃ§Ã£o de sessÃµes no CLI."""
    print("\n" + "=" * 60)
    print("ğŸ” NAVEGADOR DE SESSÃ•ES")
    print("=" * 60)
    
    sessions = await get_sessions()
    if not sessions:
        input("\nğŸ“­ Nenhuma sessÃ£o encontrada. Pressione Enter para continuar...")
        return
    
    print(f"ğŸ“Š {len(sessions)} sessÃµes encontradas")
    
    while True:
        print("\n" + "-" * 60)
        print("ğŸ” OPÃ‡Ã•ES:")
        print("1. ğŸ“‹ Listar todas as sessÃµes")
        print("2. ğŸ” Buscar sessÃ£o por ID")
        print("3. ğŸ“ Filtrar por diretÃ³rio/projeto")
        print("4. ğŸŒ Abrir sessÃ£o no viewer web")
        print("5. ğŸ“ Gerar resumo de sessÃ£o")
        print("6. ğŸ”„ Carregar e continuar sessÃ£o")
        print("0. â¬…ï¸  Voltar ao chat")
        
        try:
            choice = input("\nğŸ‘¤ Escolha uma opÃ§Ã£o: ").strip()
        except EOFError:
            break
            
        if choice == "0":
            break
        elif choice == "1":
            await list_sessions(sessions)
        elif choice == "2":
            await search_session(sessions)
        elif choice == "3":
            await filter_by_directory(sessions)
        elif choice == "4":
            await open_in_web(sessions)
        elif choice == "5":
            await generate_summary(sessions)
        elif choice == "6":
            return await load_and_continue_session(sessions)
        else:
            print("âŒ OpÃ§Ã£o invÃ¡lida")

async def list_sessions(sessions, limit=20):
    """Lista sessÃµes com paginaÃ§Ã£o."""
    print(f"\nğŸ“‹ LISTAGEM DE SESSÃ•ES (Ãºltimas {min(limit, len(sessions))})")
    print("-" * 60)
    
    # Ordenar por Ãºltima interaÃ§Ã£o (mais recentes primeiro)
    sorted_sessions = sorted(sessions, key=lambda x: x.get('last_interaction', ''), reverse=True)
    
    for i, session in enumerate(sorted_sessions[:limit]):
        # Extrai apenas a parte final do diretÃ³rio para exibiÃ§Ã£o
        directory_parts = session['directory'].split('--')
        if len(directory_parts) > 1:
            directory_short = directory_parts[-1].replace('-', '/')
        else:
            directory_short = session['directory'].replace('-', '/')
        print(f"{i+1:2d}. ğŸ“„ {session['session_id'][:12]}... | ğŸ“ {directory_short} | â° {session.get('last_interaction', 'N/A')}")
    
    if len(sessions) > limit:
        print(f"\n... e mais {len(sessions) - limit} sessÃµes")
    
    input("\nPressione Enter para continuar...")

async def search_session(sessions):
    """Busca sessÃ£o por ID parcial."""
    try:
        search_term = input("\nğŸ” Digite parte do ID da sessÃ£o: ").strip().lower()
    except EOFError:
        return
        
    if not search_term:
        return
    
    matches = [s for s in sessions if search_term in s['session_id'].lower()]
    
    if not matches:
        print(f"âŒ Nenhuma sessÃ£o encontrada com '{search_term}'")
        input("Pressione Enter para continuar...")
        return
    
    print(f"\nğŸ¯ {len(matches)} sessÃ£o(Ãµes) encontrada(s):")
    print("-" * 60)
    
    for i, session in enumerate(matches):
        directory_short = session['directory'].split('/')[-1] if '/' in session['directory'] else session['directory']
        print(f"{i+1}. ğŸ“„ {session['session_id']} | ğŸ“ {directory_short}")
    
    if len(matches) == 1:
        await show_session_details(matches[0])
    else:
        input("\nPressione Enter para continuar...")

async def filter_by_directory(sessions):
    """Filtra sessÃµes por diretÃ³rio/projeto."""
    directories = sorted(list(set(s['directory'] for s in sessions)))
    
    print(f"\nğŸ“ DIRETÃ“RIOS/PROJETOS ({len(directories)} encontrados):")
    print("-" * 60)
    
    for i, directory in enumerate(directories):
        session_count = sum(1 for s in sessions if s['directory'] == directory)
        directory_short = directory.split('/')[-1] if '/' in directory else directory
        print(f"{i+1:2d}. ğŸ“ {directory_short} ({session_count} sessÃµes)")
    
    try:
        choice = input(f"\nğŸ‘¤ Escolha um diretÃ³rio (1-{len(directories)}): ").strip()
        dir_idx = int(choice) - 1
        
        if 0 <= dir_idx < len(directories):
            selected_dir = directories[dir_idx]
            filtered_sessions = [s for s in sessions if s['directory'] == selected_dir]
            await list_sessions(filtered_sessions, 50)  # Mostrar mais sessÃµes do diretÃ³rio selecionado
        else:
            print("âŒ NÃºmero invÃ¡lido")
            input("Pressione Enter para continuar...")
    except (ValueError, EOFError):
        print("âŒ Entrada invÃ¡lida")
        input("Pressione Enter para continuar...")

async def open_in_web(sessions):
    """Abre sessÃ£o selecionada no browser web."""
    try:
        session_id = input("\nğŸŒ Digite o ID da sessÃ£o (ou parte): ").strip()
    except EOFError:
        return
        
    if not session_id:
        return
    
    matches = [s for s in sessions if session_id.lower() in s['session_id'].lower()]
    
    if not matches:
        print(f"âŒ SessÃ£o '{session_id}' nÃ£o encontrada")
        input("Pressione Enter para continuar...")
        return
    
    if len(matches) > 1:
        print(f"âš ï¸  MÃºltiplas sessÃµes encontradas ({len(matches)}). Use um ID mais especÃ­fico.")
        for session in matches[:5]:  # Mostrar apenas 5 primeiros
            print(f"   ğŸ“„ {session['session_id']}")
        input("Pressione Enter para continuar...")
        return
    
    session = matches[0]
    await show_session_details(session)

async def show_session_details(session):
    """Mostra detalhes de uma sessÃ£o especÃ­fica."""
    print("\n" + "=" * 60)
    print("ğŸ“„ DETALHES DA SESSÃƒO")
    print("=" * 60)
    
    print(f"ğŸ†” ID: {session['session_id']}")
    print(f"ğŸ“ DiretÃ³rio: {session['directory']}")
    print(f"â° Ãšltima interaÃ§Ã£o: {session.get('last_interaction', 'N/A')}")
    print(f"ğŸ“‚ Arquivo: {session.get('file_path', 'N/A')}")
    
    # Carregar estatÃ­sticas se possÃ­vel
    file_path = Path(session.get('file_path', ''))
    if file_path.exists():
        try:
            with open(file_path, 'r') as f:
                lines = f.readlines()
            
            user_msgs = sum(1 for line in lines if '"type":"user"' in line)
            assistant_msgs = sum(1 for line in lines if '"type":"assistant"' in line)
            
            print(f"ğŸ“Š EstatÃ­sticas:")
            print(f"   ğŸ“„ Linhas no arquivo: {len(lines)}")
            print(f"   ğŸ‘¤ Mensagens usuÃ¡rio: {user_msgs}")
            print(f"   ğŸ¤– Respostas Claude: {assistant_msgs}")
            print(f"   ğŸ’¬ Total mensagens: {user_msgs + assistant_msgs}")
            
        except Exception as e:
            print(f"âŒ Erro ao ler estatÃ­sticas: {str(e)}")
    
    print(f"\nğŸŒ URLs disponÃ­veis:")
    base_url = f"{VIEWER_API_URL}/{session['directory']}/{session['session_id']}"
    print(f"   ğŸ“„ Ver sessÃ£o: {base_url}")
    print(f"   ğŸ“ Resumo conciso: {base_url}/resumo?tipo=conciso")
    print(f"   ğŸ“‹ Resumo detalhado: {base_url}/resumo?tipo=detalhado")
    
    input("\nPressione Enter para continuar...")

async def generate_summary(sessions):
    """Gera resumo de uma sessÃ£o."""
    try:
        session_id = input("\nğŸ“ Digite o ID da sessÃ£o para resumo (ou parte): ").strip()
    except EOFError:
        return
        
    if not session_id:
        return
    
    matches = [s for s in sessions if session_id.lower() in s['session_id'].lower()]
    
    if not matches:
        print(f"âŒ SessÃ£o '{session_id}' nÃ£o encontrada")
        input("Pressione Enter para continuar...")
        return
    
    if len(matches) > 1:
        print(f"âš ï¸  MÃºltiplas sessÃµes encontradas ({len(matches)}). Use um ID mais especÃ­fico.")
        input("Pressione Enter para continuar...")
        return
    
    session = matches[0]
    
    print(f"\nğŸ“ Tipos de resumo disponÃ­veis:")
    print("1. ğŸ“ Conciso (20 palavras)")
    print("2. ğŸ“‹ Detalhado (400 palavras)") 
    print("3. â€¢ Bullet Points")
    
    try:
        choice = input("ğŸ‘¤ Escolha o tipo (1-3): ").strip()
        
        types_map = {"1": "conciso", "2": "detalhado", "3": "bullet_points"}
        summary_type = types_map.get(choice)
        
        if not summary_type:
            print("âŒ OpÃ§Ã£o invÃ¡lida")
            input("Pressione Enter para continuar...")
            return
        
        print(f"\nğŸ¤– Gerando resumo {summary_type}...")
        
        payload = {
            "directory": session['directory'],
            "session_id": session['session_id'],
            "summary_type": summary_type
        }
        
        response = requests.post(f"{VIEWER_API_URL}/api/summarize", json=payload, timeout=60)
        
        if response.status_code == 200:
            result = response.json()
            if result.get('success'):
                print(f"\nâœ… Resumo gerado com sucesso:")
                print("-" * 60)
                print(result.get('summary', ''))
                print("-" * 60)
            else:
                print(f"âŒ Erro na API: {result.get('error')}")
        else:
            print(f"âŒ Erro HTTP {response.status_code}")
            
    except (ValueError, EOFError, requests.RequestException) as e:
        print(f"âŒ Erro: {str(e)}")
    
    input("\nPressione Enter para continuar...")

async def load_and_continue_session(sessions, session_id=None):
    """Carrega uma sessÃ£o anterior e continua a conversa."""
    if session_id:
        session_input = session_id
    else:
        try:
            session_input = input("\nğŸ”„ Digite o ID da sessÃ£o para carregar (ou parte): ").strip()
        except EOFError:
            return None
            
        if not session_input:
            return None
    
    matches = [s for s in sessions if session_input.lower() in s['session_id'].lower()]
    
    if not matches:
        print(f"âŒ SessÃ£o '{session_input}' nÃ£o encontrada")
        # SÃ³ pede Enter se nÃ£o foi carregado diretamente
        if not session_id:
            input("Pressione Enter para continuar...")
        return None
    
    if len(matches) > 1:
        print(f"âš ï¸  MÃºltiplas sessÃµes encontradas ({len(matches)}). Mostrando as primeiras 5:")
        for i, session in enumerate(matches[:5], 1):
            print(f"   {i}. ğŸ“„ {session['session_id']} | ğŸ“ {session['directory'].split('/')[-1]}")
        
        try:
            choice = input("\nğŸ‘¤ Escolha uma sessÃ£o (1-5) ou 0 para cancelar: ").strip()
            if choice == "0":
                return None
            idx = int(choice) - 1
            if 0 <= idx < len(matches[:5]):
                session = matches[idx]
            else:
                print("âŒ OpÃ§Ã£o invÃ¡lida")
                return None
        except (ValueError, EOFError):
            return None
    else:
        session = matches[0]
    
    print(f"\nâœ… Carregando sessÃ£o: {session['session_id']}")
    print(f"ğŸ“ Projeto: {session['directory']}")
    print(f"â° Ãšltima interaÃ§Ã£o: {session['last_interaction']}")
    
    # LÃª o conteÃºdo da sessÃ£o
    try:
        with open(session['file_path'], 'r') as f:
            lines = f.readlines()
        
        print(f"\nğŸ“Š SessÃ£o carregada com {len(lines)} mensagens")
        
        # Mostra resumo das Ãºltimas mensagens
        recent_messages = []
        for line in lines[-10:]:  # Ãšltimas 10 mensagens
            try:
                data = json.loads(line)
                msg_type = data.get('type')
                
                if msg_type == 'user':
                    # Mensagem do usuÃ¡rio estÃ¡ em data.message.content
                    message = data.get('message', {})
                    content = message.get('content', '')
                    if content:
                        text = content[:80] + ('...' if len(content) > 80 else '')
                        recent_messages.append(f"ğŸ‘¤ {text}")
                        
                elif msg_type == 'assistant':
                    # Mensagem do assistente estÃ¡ em data.message.content
                    message = data.get('message', {})
                    content = message.get('content', [])
                    if isinstance(content, list) and content:
                        for block in content:
                            if isinstance(block, dict) and block.get('type') == 'text':
                                text = block.get('text', '')[:80]
                                text = text.replace('\n', ' ')
                                if text:
                                    text += '...' if len(block.get('text', '')) > 80 else ''
                                    recent_messages.append(f"ğŸ¤– {text}")
                                    break
            except Exception as e:
                continue
        
        if recent_messages:
            print("\nğŸ“ Ãšltimas mensagens da conversa:")
            for msg in recent_messages[-5:]:  # Mostra apenas as 5 Ãºltimas
                print(f"   {msg}")
        
        print("\nğŸ’¡ Para continuar esta sessÃ£o, vocÃª precisaria:")
        print("   1. Exportar o histÃ³rico para um formato compatÃ­vel")
        print("   2. Carregar o contexto no cliente Claude Code SDK")
        print("   3. Ou usar o viewer web para visualizar a sessÃ£o completa")
        
        print("\nâš ï¸  Nota: A continuaÃ§Ã£o direta de sessÃµes antigas ainda nÃ£o estÃ¡")
        print("   totalmente implementada. Use o viewer web para melhor experiÃªncia.")
        
        # SÃ³ pede Enter se nÃ£o foi carregado diretamente (session_id passado como argumento)
        if not session_id:
            input("\nPressione Enter para voltar ao menu...")
        
    except Exception as e:
        print(f"âŒ Erro ao ler sessÃ£o: {str(e)}")
        # SÃ³ pede Enter se nÃ£o foi carregado diretamente
        if not session_id:
            input("Pressione Enter para continuar...")
    
    # Retorna as mensagens histÃ³ricas para serem carregadas no contexto
    return {'session': session, 'messages': lines if 'lines' in locals() else []}

async def load_session_directly(session_id):
    """Carrega e exibe uma sessÃ£o especÃ­fica e continua o chat."""
    print("=" * 60)
    print(f"ğŸ¤– Claude Code SDK Python v{__version__} - Continuando SessÃ£o")
    print("=" * 60)
    print(f"ğŸ”„ Carregando sessÃ£o: {session_id[:12]}...")
    print("-" * 60)
    
    sessions = await get_sessions()
    session_data = None
    
    if sessions:
        # Mostra informaÃ§Ãµes da sessÃ£o
        result = await load_and_continue_session(sessions, session_id)
        # Se a sessÃ£o foi encontrada e carregada com sucesso
        if result and isinstance(result, dict):
            session_data = result
    
    if not session_data:
        print(f"âŒ Erro ao carregar sessÃ£o: {session_id}")
        print("\nğŸ’¡ Iniciando nova conversa...")
    else:
        print("\nâœ… SessÃ£o carregada! Continuando conversa...")
        print("ğŸ’¡ O contexto anterior foi carregado na memÃ³ria.")
    
    print("-" * 60)
    return session_data  # Retorna dados da sessÃ£o se carregada

async def chat_mode(session_id=None):
    """Modo chat interativo com contexto mantido."""
    session_data = None
    
    # Se foi passado um session_id, carrega a sessÃ£o primeiro
    if session_id:
        session_data = await load_session_directly(session_id)
        print("")  # Linha em branco para separaÃ§Ã£o
        # Continua para o modo chat normal apÃ³s carregar a sessÃ£o
    
    print("=" * 60)
    print(f"ğŸ¤– Claude Code SDK Python v{__version__} - Chat Interativo")
    print("=" * 60)
    print("ğŸ’¬ Digite suas mensagens e pressione Enter para enviar")
    print("ğŸ“ Comandos: 's' ou 'sair' para sair, Ctrl+I para interromper")
    print("ğŸ”„ Comandos: 'l' ou 'limpar', 'n' ou 'novo' para limpar contexto")
    print("ğŸ” Comandos: 'v' ou 'viewer' para navegar sessÃµes")
    print("-" * 60)
    
    client = ClaudeSDKClient()
    
    # Se temos dados de sessÃ£o, precisamos carregar o contexto
    if session_data and session_data.get('messages'):
        print("\nğŸ”„ Carregando contexto da conversa anterior...")
        
        # Processa mensagens histÃ³ricas e carrega no cliente
        messages_to_load = []
        for line in session_data['messages']:
            try:
                data = json.loads(line)
                msg_type = data.get('type')
                message = data.get('message', {})
                
                if msg_type == 'user':
                    content = message.get('content', '')
                    if content and not isinstance(content, list):  # Evita mensagens de tool_result
                        messages_to_load.append({'type': 'user', 'content': content})
                elif msg_type == 'assistant':
                    content = message.get('content', [])
                    if isinstance(content, list):
                        for block in content:
                            if isinstance(block, dict) and block.get('type') == 'text':
                                text = block.get('text', '')
                                if text:
                                    messages_to_load.append({'type': 'assistant', 'content': text})
                                    break
            except:
                continue
        
        # Conecta com contexto histÃ³rico
        print(f"ğŸ“¦ {len(messages_to_load)} mensagens do histÃ³rico carregadas")
        
        # Por enquanto, vamos criar um prompt inicial resumindo o contexto
        if messages_to_load:
            context_summary = "\nğŸ“ Contexto da conversa anterior:\n"
            for msg in messages_to_load[-6:]:  # Ãšltimas 6 mensagens
                if msg['type'] == 'user':
                    context_summary += f"UsuÃ¡rio: {msg['content'][:100]}...\n" if len(msg['content']) > 100 else f"UsuÃ¡rio: {msg['content']}\n"
                else:
                    context_summary += f"Claude: {msg['content'][:100]}...\n" if len(msg['content']) > 100 else f"Claude: {msg['content']}\n"
            
            print(context_summary)
            print("-" * 60)
    
    await client.connect()
    
    # Se temos contexto para estabelecer, envia como primeira mensagem invisÃ­vel
    if session_data and messages_to_load:
        context_prompt = "Contexto: Estamos continuando uma conversa anterior. "
        
        # Extrai informaÃ§Ãµes importantes do contexto
        user_info = {}
        for msg in messages_to_load:
            if msg['type'] == 'user' and 'nome' in msg['content'].lower():
                # Procura por padrÃµes como "meu nome Ã© X"
                content = msg['content'].lower()
                if 'meu nome Ã©' in content:
                    parts = content.split('meu nome Ã©')
                    if len(parts) > 1:
                        name = parts[1].strip().split()[0]
                        user_info['nome'] = name.capitalize()
        
        if user_info:
            context_prompt += f"InformaÃ§Ãµes do usuÃ¡rio: Nome = {user_info.get('nome', 'nÃ£o informado')}. "
        
        context_prompt += f"Tivemos {len(messages_to_load)} trocas de mensagens. "
        context_prompt += "Continue a conversa naturalmente lembrando do contexto anterior. NÃ£o mencione que estÃ¡ continuando uma conversa anterior, apenas responda normalmente."
        
        # Envia contexto silenciosamente
        await client.query(context_prompt)
        # Consome resposta sem mostrar
        async for message in client.receive_response():
            pass  # Descarta a resposta do estabelecimento de contexto
    
    # Imprime o prompt inicial imediatamente
    print("\nğŸ‘¤ VocÃª: ", end="", flush=True)
    
    try:
        while True:
            # Aguarda input do usuÃ¡rio
            try:
                prompt = input().strip()  # NÃ£o precisa do prompt aqui, jÃ¡ foi impresso
            except EOFError:
                break
                
            if not prompt:
                continue
                
            # Comandos especiais
            if prompt.lower() in ['s', 'sair']:
                print("ğŸ‘‹ AtÃ© logo!")
                break
            
            if prompt.lower() in ['l', 'limpar', 'n', 'novo']:
                print("ğŸ”„ Contexto limpo. Iniciando nova conversa...")
                await client.disconnect()
                client = ClaudeSDKClient()
                await client.connect()
                continue
            
            if prompt.lower() in ['v', 'viewer']:
                await session_browser()
                continue
            
            # Envia query e mostra resposta
            print("-" * 40)
            try:
                await client.query(prompt)
                
                async for message in client.receive_response():
                    if isinstance(message, AssistantMessage):
                        print("ğŸ¤– Claude: ", end="")
                        for block in message.content:
                            if isinstance(block, TextBlock):
                                print(block.text)
                    elif isinstance(message, ResultMessage):
                        if hasattr(message, 'usage') and message.usage:
                            tokens_info = ""
                            if hasattr(message.usage, 'input_tokens'):
                                tokens_info = f"[Tokens: {message.usage.input_tokens}â†‘ {message.usage.output_tokens}â†“]"
                            elif isinstance(message.usage, dict):
                                tokens_info = f"[Tokens: {message.usage.get('input_tokens', 0)}â†‘ {message.usage.get('output_tokens', 0)}â†“]"
                            if tokens_info:
                                print(f"\n{tokens_info}", end="")
                        if hasattr(message, 'total_cost_usd') and message.total_cost_usd:
                            print(f" [Custo: ${message.total_cost_usd:.6f}]")
                        
            except Exception as e:
                print(f"âŒ Erro: {e}")
                
    except KeyboardInterrupt:
        print("\n\nğŸ‘‹ Interrompido!")
    finally:
        await client.disconnect()

if __name__ == "__main__":
    # Desabilita buffer do output
    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 1)
    sys.stderr = os.fdopen(sys.stderr.fileno(), 'w', 1)
    
    # Verifica se foi passado um ID de sessÃ£o como argumento
    session_id = None
    if len(sys.argv) > 1:
        session_id = sys.argv[1]
    
    # Executa modo chat (com ou sem sessÃ£o especÃ­fica)
    try:
        asyncio.run(chat_mode(session_id))
    except KeyboardInterrupt:
        print("\nğŸ‘‹ AtÃ© logo!")
        sys.exit(0)
    except Exception as e:
        print(f"âŒ Erro fatal: {e}")
        sys.exit(1)
    finally:
        sys.exit(0)